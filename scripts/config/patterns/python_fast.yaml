# Python Fast Pattern Validation
# Used by validate_python_patterns() in scripts/automation/validators.py
#
# These patterns define fast checks that run BEFORE expensive LLM audits.
# Fast pattern checks prevent obvious violations from wasting LLM tokens.

version: "1.0.0"

patterns:
  # Non-empty __init__.py files
  - name: "non_empty_init"
    check_type: "file_content"
    file_match: "**/__init__.py"
    condition: "not_empty"
    error_template: |
      ❌ NON-EMPTY __init__.py FILE

      __init__.py files MUST be empty.
      Remove all content from this file.

  # Forbidden path manipulation pattern
  - name: "parent_parent"
    check_type: "content_pattern"
    pattern: '.parent.parent'
    allow_removal: true  # Only block ADDITIONS of this pattern
    error_template: |
      ❌ FORBIDDEN CODE PATTERN: .parent.parent

      NEVER use Path(__file__).parent.parent or similar patterns.

      Use the _ensure_repo_on_path() pattern from scripts/run_tests.py:

      def _ensure_repo_on_path() -> Path:
          current = Path(__file__).resolve().parent
          while current != current.parent:
              if (current / ".git").exists() and (current / "base").exists():
                  sys.path.insert(0, str(current))
                  return current
              current = current.parent
          raise RuntimeError("Unable to locate AMI orchestrator root")

  # Code quality suppressions without justification
  - name: "code_suppression"
    check_type: "content_pattern"
    patterns:
      - '# noqa'
      - '# type: ignore'
      - '# pylint: disable'
      - '# mypy: ignore-errors'
      - '# fmt: off'
      - '# ruff: noqa'
      - '# pragma: no cover'
    allow_removal: true  # CRITICAL: Only block ADDITIONS, allow cleanup
    error_template: |
      ❌ CODE QUALITY SUPPRESSION WITHOUT JUSTIFICATION

      Zero-tolerance policy: Code quality issues MUST be fixed, not suppressed.

      FORBIDDEN additions:
        # noqa: <codes> (except E402 in module_setup.py, run_tests.py, scripts/)
        # type: ignore (without [error-code] and justification)
        # pylint: disable
        # mypy: ignore-errors
        # fmt: off
        # ruff: noqa
        # pragma: no cover

      ALLOWED:
        # noqa: E402  (in module_setup.py, run_tests.py, scripts/ for path discovery)
        # type: ignore[<error-code>]  # <library>: <reason> (with justification)

      If you are REMOVING suppressions, this error should not appear.
      If it does, the validation logic has a bug - contact the maintainer.

    # Exemption rules (aligned with patterns_core.txt lines 30-44)
    exemptions:
      # E402 (module import not at top) allowed in path discovery files
      - path_patterns:
          - "**/module_setup.py"
          - "**/run_tests.py"
          - "scripts/**/*.py"
        allowed_patterns:
          - '# noqa: E402'
        justification: "Required for path discovery before imports"

      # type:ignore with justification (third-party type stub issues)
      - path_patterns:
          - "**/*.py"
        allowed_pattern_regex: '# type: ignore\[[\w-]+\]\s+#\s+\w+:\s+.+'
        justification: "Third-party library type stub issue with inline comment"

  # Banned UUID versions
  - name: "banned_uuid_versions"
    check_type: "content_pattern"
    is_regex: true
    patterns:
      - 'uuid\.uuid1\('
      - 'uuid\.uuid3\('
      - 'uuid\.uuid4\('
      - 'uuid\.uuid5\('
      - 'uuid\.uuid6\('
      - 'uuid\.uuid8\('
      - '\buuid1\('
      - '\buuid3\('
      - '\buuid4\('
      - '\buuid5\('
      - '\buuid6\('
      - '\buuid8\('
      - 'from uuid import.*uuid[13456]8?[^7]'
    allow_removal: true
    error_template: |
      ❌ BANNED UUID VERSION

      Only uuid7() is allowed for time-sortable, globally unique IDs.

      FORBIDDEN: uuid.uuid1(), uuid.uuid3(), uuid.uuid4(), uuid.uuid5(), uuid.uuid6(), uuid.uuid8()
      FORBIDDEN: from uuid import uuid1, uuid3, uuid4, uuid5, uuid6, uuid8

      REQUIRED: uuid.uuid7() or from uuid import uuid7

  # Complex nested dict type annotations - use Pydantic models instead
  - name: "complex_dict_annotations"
    check_type: "content_pattern"
    is_regex: true
    patterns:
      - 'dict\[str,\s*dict\['
      - 'dict\[str,\s*list\[dict'
      - 'dict\[str,\s*tuple\['
      - 'list\[dict\[str,\s*dict'
      - 'tuple\[.*dict\[.*dict'
    allow_removal: true
    error_template: |
      ❌ COMPLEX NESTED DICT TYPE ANNOTATION

      Nested dict type annotations like dict[str, dict[str, str]] are unmaintainable.

      FORBIDDEN examples:
        self._cache: dict[str, dict[str, str]] = {}
        data: dict[str, list[dict[str, Any]]] = {}
        config: dict[str, tuple[str, int]] = {}

      REQUIRED: Define Pydantic models for structured data

      Example FIX:
        # Before (WRONG):
        self._metadata_cache: dict[str, dict[str, str]] = {}

        # After (CORRECT):
        from pydantic import BaseModel

        class MetadataEntry(BaseModel):
            version: str
            author: str
            # ... other fields with clear names

        self._metadata_cache: dict[str, MetadataEntry] = {}

      Why Pydantic models are required:
      1. Self-documenting: Field names show what data means
      2. Type-safe: Automatic validation at runtime
      3. Maintainable: Easy to evolve schema
      4. Testable: Clear structure for mocking
      5. Debuggable: Readable repr() output

  # Banned word: "pre-existing" - zero tolerance policy
  - name: "banned_word_preexisting"
    check_type: "content_pattern"
    is_regex: true
    patterns:
      - '\bpre-existing\b'
      - '\bpreexisting\b'
      - '\bpre existing\b'
    allow_removal: true
    error_template: |
      ❌ BANNED WORD: "pre-existing"

      ZERO TOLERANCE: All code quality issues are YOUR responsibility.

      FORBIDDEN:
        - "pre-existing error"
        - "preexisting issue"
        - "pre existing bug"
        - ANY form of this word in code, comments, or error messages

      WHY BANNED:
      This word implies deflecting responsibility for code quality issues.
      ALL errors are your fault and your responsibility to fix.

      REMOVE this word immediately.
