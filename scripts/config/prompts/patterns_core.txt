## VIOLATION PATTERNS - ZERO TOLERANCE (69 TOTAL)

### CRITICAL

**SQL Injection**: `query = f"SELECT * FROM {var}"` | `cursor.execute(f"...")`

**Subprocess RCE**: `subprocess.run(untrusted)` with fallback chains

**Auth Downgrade**: `try: oauth(); except: api_key()` - weaker auth on fail

**Security Default**: `if not security_attr: return True/False` - bypasses checks when missing

**Plain Sensitive Data**: `field: str` for credentials/tokens (use `SecretStr`)

**Crypto Verify → Bool**: `def verify(): compare(); return bool` - hides failures

**Validation → False**: `def verify(): if not valid: return False` - should raise

**Stub/No-Op**: `def method(): return True` - bypasses security, missing functionality

**Rollback Suppression**: `try: rollback(); except: pass` - data corruption

**Uncaught DDL**: `cursor.execute("CREATE TABLE...")` - no try/except

**DB Migration in App**: `ALTER TABLE ... ALTER COLUMN ... TYPE ...` or type checking `if sql_type == "TIMESTAMPTZ" and data_type == "text": needs_migration = True`
- **Allowed only in**: `migrations/*.sql`, `alembic/versions/*.py`, `scripts/*_migration.py`
- **Forbidden in**: `*_create.py`, `*_update.py`, `*_dao.py`, `*_crud.py`
- **Correct approach**: Dev/test: drop and recreate in test fixtures. Production: versioned migration scripts (Alembic/SQL)

**Suppression Without Justification**: `# noqa`, `# type: ignore`, `# pylint: disable`, `# mypy: ignore-errors`, `# fmt: off`, `# ruff: noqa`, `# pragma: no cover` WITHOUT multi-line justification
- **ALLOWED**: `# noqa: E402` on import lines in `**/module_setup.py`, `**/run_tests.py`, `scripts/**/*.py` (E402 = module import not at top; these files MUST do path discovery before imports)
- **ALLOWED**: `# type: ignore[<error-code>]  # <library-name>: <reason>` (third-party type stub issue)
- **Example NOT A VIOLATION**:
  ```python
  # In ux/module_setup.py:
  import sys  # noqa: E402  ← CORRECT - required for path discovery
  import os   # noqa: E402  ← CORRECT - required for path discovery
  ```
- **Example VIOLATION**:
  ```python
  # In src/main.py:
  result = dangerous_call()  # type: ignore  ← VIOLATION - needs justification
  ```
- **IMPORTANT**: Don't confuse inline `# noqa: E402` markers (required on specific lines) with file-level exemption configs. Both used together: file-level exempts file, inline marks specific violating lines

**Disabled Security**: `def check_quota(): return True  # Always allow`

**Config Exemption Without Justification**: ADDING to exemption lists (ruff.toml, mypy.ini, etc.) without comment explaining:
  1. Why exemption needed
  2. What rules violated
  3. Why can't fix (architectural constraint)
  4. When/how to remove
  5. Alternatives rejected
- **REMOVING exemptions always allowed**
- Required format:
  ```python
  # file.py: E402 (module import not at top)
  # Reason: path discovery before imports
  # Cannot fix: architectural requirement
  # Removal: when paths refactored
  # Alternatives: PYTHONPATH (fragile), __init__ (not package)
  Path("file.py"),
  ```

**Config File Additions Without Precedent**: ADDING entries to ruff.toml/pyproject.toml/mypy.ini when NO existing precedent
- **VIOLATION Example** (ruff.toml when no other single-file entries exist):
  ```toml
  "scripts/automation/**/*.py" = ["T201", "S603"]  # Existing pattern
  "scripts/automation/audit.py" = ["C901"]  # WRONG - no other single-file entries
  ```
- **CORRECT Approach**: Refactor `_audit_file()` to reduce complexity instead of adding C901 exception
- **ALLOWED**: Adding to existing patterns that match: `"scripts/automation/audit.py" = ["T201", "S603"]` (matches `**/*.py` pattern)
- **FIX CODE instead of config - refactor complex functions, remove prints, fix security**
- **REMOVING config entries always allowed**

**Assert in Production**: `assert condition, "msg"` for validation (disabled with `python -O`)
- **ALLOWED**: Test files only
- **FIX**: `if not condition: raise ValueError("msg")`

**Missing Type Hints**: Functions/methods without type hints; using `Any` instead of concrete types; untyped collections (`dict`, `list`) instead of generic (`dict[str, int]`, `list[str]`)
- **VIOLATION**: `Any` without inline comment justification
- **Example VIOLATION**:
  ```python
  def process_data(config: Any, items: Any) -> Any:  # VIOLATION - no justification
      return results
  ```
- **Example ALLOWED**:
  ```python
  def process_response(data: Any) -> dict[str, Any]:  # Any: boto3 DynamoDB returns untyped nested dicts
      return transform(data)
  ```
- **Correct approach**: Use concrete types; `dict[str, Any]` not bare `dict`; `from __future__ import annotations` for forward refs; `TypeVar`, `Protocol`, `TypedDict` for complex types; inline comment justifying each `Any`

**@dataclass Instead of Pydantic**: ADDING `@dataclass` in production code
- **Example VIOLATION**:
  ```python
  from dataclasses import dataclass

  @dataclass
  class UserConfig:  # VIOLATION - use Pydantic BaseModel
      name: str
      email: str
  ```
- **Required fix**:
  ```python
  from pydantic import BaseModel, Field

  class UserConfig(BaseModel):
      name: str
      email: str

      class Config:
          arbitrary_types_allowed = True
  ```
- **IMPORTANT**: REMOVING dataclasses (converting to Pydantic) ALWAYS allowed and encouraged
- **Correct approach**: Use Pydantic BaseModel for all data models; use Field() for descriptions; add Config with arbitrary_types_allowed for Path types

**Complex Return Types Instead of Pydantic**:
- **VIOLATIONS**: `tuple[str, list[dict]]`, `tuple[str, list[dict[str, str]]]`, `dict[str, str|int]`, `tuple[str, int, bool]` (3+), nested structures
- **ALLOWED**: `tuple[str, int]` (2 simple types), `list[str]`, `dict[str, int]`, `str|None`, simple built-ins (`str`, `int`, `bool`, `Path`)
- **VIOLATION Example**:
  ```python
  def parse(input: str) -> tuple[str, list[dict[str, Any]]]:  # WRONG
      return "success", [{"id": 1}]
  ```
- **FIX Example**:
  ```python
  from pydantic import BaseModel
  class ParseResult(BaseModel):
      status: str
      items: list[dict[str, Any]]
  def parse(input: str) -> ParseResult:  # CORRECT
      return ParseResult(status="success", items=[{"id": 1}])
  ```

### HIGH

**Shell Continue on Error**: `for x in ...; do cmd || continue; done`

**Exception → || Operator**: `command || fallback` or `command || true`

**Pipeline Failure Masking**: `cmd1 | cmd2 || fallback`

**Import Suppression**: `try: import X; except: continue`

**Lazy Imports**: Import inside function/method bodies instead of module top-level
- **Example VIOLATION**:
  ```python
  def process_data():
      from pathlib import Path  # VIOLATION
      from .config import get_config  # VIOLATION
      return Path("/tmp")
  ```
- **Required fix**:
  ```python
  from pathlib import Path
  from scripts.automation.config import get_config

  def process_data():
      return Path("/tmp")
  ```
- **ALLOWED**: Only with extensive multi-line justification explaining why architecturally required (circular dependency cannot refactor, optional heavy dependency must defer)
- **IMPORTANT**: REMOVING lazy imports (moving to top-level) ALWAYS allowed and encouraged, even if have justification
- **Correct approach**: All imports at module top-level; use `TYPE_CHECKING` guard for type-only imports; refactor circular dependencies

**Relative Imports**: Using relative dot notation (`from .module` or `from ..package.module`)
- **Example VIOLATION**:
  ```python
  from .config import get_config  # VIOLATION
  from .logger import get_logger  # VIOLATION
  from ..utils import helper  # VIOLATION
  ```
- **Required fix**:
  ```python
  from scripts.automation.config import get_config
  from scripts.automation.logger import get_logger
  from scripts.utils import helper
  ```
- **ALLOWED**: NEVER - all imports must be absolute
- **IMPORTANT**: REMOVING relative imports (converting to absolute) ALWAYS allowed and encouraged

**Exception → Empty Collection**: `except: return {}/[]/None`

**Missing Related Objects Skipped**: `for id in ids: obj=find(id); if obj: use(obj)` - broken refs ignored

**contextlib.suppress**: `with suppress(Exception): risky()`

**Invalid Input → Sentinel**: `if not valid: return [0.0]*N or "" or {}`

**Finally Unconditional Cleanup**: `try: commit(); finally: discard()` - runs regardless of success

**Exception → False**: `except: return False`

**Partial Success Count**: `count=0; for x: try: process(); count+=1; except: pass; return count`

**Warning + Continue**: `for x: try: op(); except: logger.warning(); continue`

**Missing Exception Handling**: `result = risky()` - no try/except

**Partial Deletion**: `for item: delete(item)` - no failure tracking

**Exception → Response Object**: `except: return (500, "error")` or error_response

**Validation → Bool**: `def is_valid(): return False` - should raise

**Stub → Safe Default**: `def method(): return False/None/[]` - incomplete masked as valid

**Exception Type Conversion**: `except SpecificError: raise DifferentError()` - loses context (use `from e`)

**Exception → String Sentinel**: `except: return "[SENTINEL]"`

**Exception → Queued Status**: `except: return "queued"/"pending"` - failures masked

**Missing Exception Import**: `raise CustomError()` - never imported

**Resource Not Found → Sentinel**: `if not resource: return None/False/[]` WHERE method signature does NOT include `| None` return type OR lacks docstring documenting None return
- **ALLOWED**:
  - Methods with explicit `-> T | None` return type implementing abstract interface requiring None
  - Methods with docstring stating "Returns None if not found" or similar
  - DAO read operations (find_by_id, find_one) returning None for not-found records (standard pattern)

**ImportError → RuntimeError**: `except ImportError: raise RuntimeError()`

**Uncaught HTTP Exception**: `response.raise_for_status()` - no try/except

**User Input Without Validation**: `input = getpass(); use(input)`

**Exception → Error Collection**: `except: results["errors"].append(str(e))`

**Exception → logger.error() Only**: `except e: logger.error(e)` - no raise

**Search Loop Without Exception**: `for x: if cond: result=x; break; use(result or fallback)`

**Missing Timeout Handling**: `result = timeout_op()` - no try/except

**Subprocess Exit Ignored**: `subprocess.run(cmd, check=False)` or `subprocess.call(cmd)`

**Exception → None**: `except: return None` WHERE method signature does NOT include `| None` return type OR lacks docstring documenting None return
- **ALLOWED**:
  - Methods with explicit `-> T | None` return type implementing abstract interface requiring None
  - Methods with docstring stating "Returns None if not found" or similar
  - DAO read operations (find_by_id, find_one) returning None for not-found records (standard pattern)

**Exception → Numeric Sentinel**: `except: return 1` or `return 0`

**Command → Validation Fail**: `RESULT=$(cmd) || { convert_to_deny; exit 0; }`

**Command → Default Output**: `result=$(cmd || echo "0")`

**Exit Code → String**: `if cmd >/dev/null; then result="PASS"; else result="FAIL"; fi`

**Stderr Redirect**: `command 2>/dev/null` or `2>&1` - suppresses errors

**Uncaught Environment**: `value = os.environ["VAR"]` or `int(os.environ["VAR"])` - no try/except

**Uncaught JSON Parse**: `data = json.loads(s)` - no try/except

**Assert-Only Validation**: `assert condition` - bypassed in optimized mode

**Exception → Test Skip**: `except e: if "substring" in str(e): pytest.skip()`

**Test Skipping**: `@pytest.mark.skip`, `pytest.skip()`, `unittest.skip()`, `self.skipTest()`
- **ZERO TOLERANCE** - tests must pass or fail, never skip
- **FIX**: Fix the issue or remove test

**Unvalidated Query Result**: `result = execute(sql); use(result)` - no validation

### MEDIUM

**Exit Code → Success**: Script continues after command failure

**Git Suppression**: `git cmd || git fallback || true`

**Exception → Original Input**: `except: return input`

**Warning + Sentinel**: `if invalid: logger.warning(); return None/False`

**Implicit Default via Truthiness**: `value = param or default` - treats falsy as missing

**TODO/Production Comments**: `# TODO: implement` or `# In production...`

**Cleanup Suppression**: `try: session.close(); except: pass`

**Placeholder Before NotImplementedError**: `_ = var; raise NotImplementedError()`

**Implicit Defaults in Optional**: `field: Type|None = Field(default=value)`

**Wrong Exception Type**: `raise ValueError()` - should raise domain-specific

**Dict .get() Silent None**: `value = data.get("key")` - can't distinguish null from missing

**Implicit Defaults in Required**: `field: Type = default`

**Hardcoded Retry Logic**: `max_retries = 3`

**Non-Empty __init__.py**: Imports, `__all__`, re-exports, code in `__init__.py`
- **ALLOWED**: Empty or comments/docstrings only

**Environment Implicit Default**: `os.environ.get("REQUIRED", "")` or `get("VAR", default)`

**Output Format Fallback Chain**: `if result=="EXPECTED": exit 0; elif grep "EXPECTED": exit 0; else: exit 1`

**Test Exception Without Assertion**: `with pytest.raises(Exception): op()` - no match= or assertion

**Test Validates Stub**: `assert stub_method() == expected_sentinel`

**Type Checker Config Suppression**: `ignore_missing_imports = True` or `exclude = pattern`

**Continue/Skip on Error**: `for x: try: process(); except: continue`

**Retry Logic**: `for attempt in range(retries): try: return op(); except: sleep(backoff)`

**Fallback Chain**: `try: return primary(); except: try: return fallback(); except: return default()`

**Health Check → False**: `try: service.ping(); return True; except: return False`

**Distributed → Local Fallback**: `except RedisError: return local_cache.get(key)` - loses guarantees

**DateTime Parse → String**: `except ValueError: return value` - wrong type propagated

**Attribute Access or Operator**: `self.attr or default` - None/0/False masked

**Uncaught Type Conversion**: `value = float(input)` - should wrap and raise domain error

**Table Not Found → Empty**: `except TableNotFoundError: return []`

**Rollback in Exception**: `except: for op: try: rollback(op); except: pass`

**Partial Success Without Tracking**: `return {"success": True, "results": results}` if any failed

**JSON Parse → Fallback**: `except JSONDecodeError: data = {}`

## PERMITTED EXCEPTIONS (LIMITED)

**Cleanup in Finally**: `finally: with suppress(Exception): resource.close()`

**Documented "Returns None"**: `-> Config|None` with `"""Returns None if not found."""` docstring

**Test Fixtures**: `@pytest.fixture def empty_list(): return []`

**Not a Git Repo**: `except CalledProcessError as e: if "not a git repository" in e.stderr: return None; raise`
