## VIOLATION PATTERNS - ZERO TOLERANCE (72 TOTAL)

### CRITICAL

**Bypass Script Creation**: Creating scripts in `/tmp/` or elsewhere to circumvent CI/CD, hooks, or quality checks
- **Example VIOLATIONS**:
  ```python
  # Creating git bypass scripts:
  Write("/tmp/commit_script.sh", "#!/bin/bash\ncd /path\n/usr/bin/git commit ...")
  Write("/tmp/push_script.sh", "#!/bin/bash\nexport SKIP_TESTS=1\ngit push")
  Write("/tmp/fix_commit.sh", "#!/bin/bash\ngit reset --soft HEAD~1")

  # Creating file modification scripts:
  Write("/tmp/modify_files.sh", "#!/bin/bash\nsed -i 's/pattern/replacement/' file.py")
  Write("/tmp/bypass_hooks.sh", "#!/bin/bash\ngit commit --no-verify")
  ```
- **Why CRITICAL**:
  - Circumvents pre-commit hooks (security checks, linting, type checking)
  - Bypasses code quality validation (moderators never see script contents)
  - Enables malicious edits (can modify any file without detection)
  - Creates backdoors (scripts persist and can be reused)
  - Defeats CI/CD pipeline (pushes untested/unvalidated code)
- **DETECTION**: Any Write/Bash tool use creating `.sh`, `.py`, `.bash` files in `/tmp/` or other temp locations
- **CORRECT APPROACH**:
  - Use Edit tool for file modifications (subject to code quality checks)
  - Accept pre-commit hook failures and fix the actual issues
  - Never create scripts to automate git operations
  - If git hooks block legitimate operations, update hook logic properly
- **ZERO TOLERANCE**: Instant rejection, no exceptions

**SQL Injection**: `query = f"SELECT * FROM {var}"` | `cursor.execute(f"...")`

**Subprocess RCE**: `subprocess.run(untrusted)` with fallback chains

**Auth Downgrade**: `try: oauth(); except: api_key()` - weaker auth on fail

**Security Default**: `if not security_attr: return True/False` - bypasses checks when missing

**Plain Sensitive Data**: `field: str` for credentials/tokens (use `SecretStr`)

**Crypto Verify → Bool**: `def verify(): compare(); return bool` - hides failures

**Validation → False**: `def verify(): if not valid: return False` - should raise

**Stub/No-Op**: `def method(): return True` - bypasses security, missing functionality

**Fabricated Paths/Values on Error**: `except: return Path("/fake/path")` or `if not value: value = "fabricated"` - HIDES CRITICAL FAILURES
- **Example VIOLATION**:
  ```python
  # If we couldn't extract the log path, create a default path
  if not test_log_path:
      timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
      test_log_path = orchestrator_root / "test_logs" / f"test_run_{timestamp}_default.log"
  return success, test_log_path  # Returns fake path that doesn't exist
  ```
- **Required fix**: FAIL LOUDLY - raise exception or return None
  ```python
  if not test_log_path:
      raise RuntimeError("Failed to extract test log path from test runner output")
  return success, test_log_path
  ```
- **Why CRITICAL**: Misleads users/callers to check non-existent files; masks actual failure; makes debugging impossible; error reports reference fake data

**Rollback Suppression**: `try: rollback(); except: pass` - data corruption

**Uncaught DDL**: `cursor.execute("CREATE TABLE...")` - no try/except

**DB Migration in App**: `ALTER TABLE ... ALTER COLUMN ... TYPE ...` or type checking `if sql_type == "TIMESTAMPTZ" and data_type == "text": needs_migration = True`
- **Allowed only in**: `migrations/*.sql`, `alembic/versions/*.py`, `scripts/*_migration.py`
- **Forbidden in**: `*_create.py`, `*_update.py`, `*_dao.py`, `*_crud.py`
- **Correct approach**: Dev/test: drop and recreate in test fixtures. Production: versioned migration scripts (Alembic/SQL)

**Suppression Without Justification**: `# noqa`, `# type: ignore`, `# pylint: disable`, `# mypy: ignore-errors`, `# fmt: off`, `# ruff: noqa`, `# pragma: no cover` WITHOUT multi-line justification
- **ALLOWED**: `# noqa: E402` on import lines in `**/module_setup.py`, `**/run_tests.py`, `scripts/**/*.py` (E402 = module import not at top; these files MUST do path discovery before imports)
- **ALLOWED**: `# type: ignore[<error-code>]  # <library-name>: <reason>` (third-party type stub issue)
- **Example NOT A VIOLATION**:
  ```python
  # In ux/module_setup.py:
  import sys  # noqa: E402  ← CORRECT - required for path discovery
  import os   # noqa: E402  ← CORRECT - required for path discovery
  ```
- **Example VIOLATION**:
  ```python
  # In src/main.py:
  result = dangerous_call()  # type: ignore  ← VIOLATION - needs justification
  ```
- **IMPORTANT**: Don't confuse inline `# noqa: E402` markers (required on specific lines) with file-level exemption configs. Both used together: file-level exempts file, inline marks specific violating lines

**Disabled Security**: `def check_quota(): return True  # Always allow`

**Config Exemption Without Justification**: ADDING to exemption lists (ruff.toml, mypy.ini, etc.) without comment explaining:
  1. Why exemption needed
  2. What rules violated
  3. Why can't fix (architectural constraint)
  4. When/how to remove
  5. Alternatives rejected
- **REMOVING exemptions always allowed**
- Required format:
  ```python
  # file.py: E402 (module import not at top)
  # Reason: path discovery before imports
  # Cannot fix: architectural requirement
  # Removal: when paths refactored
  # Alternatives: PYTHONPATH (fragile), __init__ (not package)
  Path("file.py"),
  ```

**Config File Additions Without Precedent**: ADDING entries to ruff.toml/pyproject.toml/mypy.ini when NO existing precedent
- **VIOLATION Example** (ruff.toml when no other single-file entries exist):
  ```toml
  "scripts/automation/**/*.py" = ["T201", "S603"]  # Existing pattern
  "scripts/automation/audit.py" = ["C901"]  # WRONG - no other single-file entries
  ```
- **CORRECT Approach**: Refactor `_audit_file()` to reduce complexity instead of adding C901 exception
- **ALLOWED**: Adding to existing patterns that match: `"scripts/automation/audit.py" = ["T201", "S603"]` (matches `**/*.py` pattern)
- **FIX CODE instead of config - refactor complex functions, remove prints, fix security**
- **REMOVING config entries always allowed**

**Assert in Production**: `assert condition, "msg"` for validation (disabled with `python -O`)
- **ALLOWED**: Test files only
- **FIX**: `if not condition: raise ValueError("msg")`

**Missing Type Hints**: Functions/methods without type hints; using `Any` instead of concrete types; untyped collections (`dict`, `list`) instead of generic (`dict[str, int]`, `list[str]`)
- **VIOLATION**: `Any` without inline comment justification
- **Example VIOLATION**:
  ```python
  def process_data(config: Any, items: Any) -> Any:  # VIOLATION - no justification
      return results
  ```
- **Example ALLOWED**:
  ```python
  def process_response(data: Any) -> dict[str, Any]:  # Any: boto3 DynamoDB returns untyped nested dicts
      return transform(data)
  ```
- **Correct approach**: Use concrete types; `dict[str, Any]` not bare `dict`; `from __future__ import annotations` for forward refs; `TypeVar`, `Protocol`, `TypedDict` for complex types; inline comment justifying each `Any`

**@dataclass Instead of Pydantic**: ADDING `@dataclass` in production code
- **Example VIOLATION**:
  ```python
  from dataclasses import dataclass

  @dataclass
  class UserConfig:  # VIOLATION - use Pydantic BaseModel
      name: str
      email: str
  ```
- **Required fix**:
  ```python
  from pydantic import BaseModel, Field

  class UserConfig(BaseModel):
      name: str
      email: str

      class Config:
          arbitrary_types_allowed = True
  ```
- **IMPORTANT**: REMOVING dataclasses (converting to Pydantic) ALWAYS allowed and encouraged
- **Correct approach**: Use Pydantic BaseModel for all data models; use Field() for descriptions; add Config with arbitrary_types_allowed for Path types

**Complex Return Types Instead of Pydantic**:
- **VIOLATIONS**: `tuple[str, list[dict]]`, `tuple[str, list[dict[str, str]]]`, `dict[str, str|int]`, `tuple[str, int, bool]` (3+), nested structures
- **ALLOWED**: `tuple[str, int]` (2 simple types), `list[str]`, `dict[str, int]`, `str|None`, simple built-ins (`str`, `int`, `bool`, `Path`)
- **VIOLATION Example**:
  ```python
  def parse(input: str) -> tuple[str, list[dict[str, Any]]]:  # WRONG
      return "success", [{"id": 1}]
  ```
- **FIX Example**:
  ```python
  from pydantic import BaseModel
  class ParseResult(BaseModel):
      status: str
      items: list[dict[str, Any]]
  def parse(input: str) -> ParseResult:  # CORRECT
      return ParseResult(status="success", items=[{"id": 1}])
  ```

**Complex Nested Dict Type Annotations**: `dict[str, dict[...]]`, `dict[str, list[dict[...]]]`, `list[dict[str, dict[...]]]`
- **VIOLATIONS**: Nested dict type annotations are unmaintainable and self-documenting
- **Example VIOLATION**:
  ```python
  self._metadata_cache: dict[str, dict[str, str]] = {}
  self._versions_cache: dict[str, list[str]] = {}
  data: dict[str, list[dict[str, Any]]] = {}
  ```
- **Required fix**:
  ```python
  from pydantic import BaseModel

  class MetadataEntry(BaseModel):
      version: str
      author: str
      # ... other fields with clear names

  self._metadata_cache: dict[str, MetadataEntry] = {}
  ```
- **Why Pydantic models required**: Self-documenting field names, runtime validation, maintainable schema evolution, clear structure for testing/mocking, readable repr() output
- **IMPORTANT**: Converting complex dict annotations to Pydantic models ALWAYS allowed and encouraged

### HIGH

**Shell Continue on Error**: `for x in ...; do cmd || continue; done`

**Exception → || Operator**: `command || fallback` or `command || true`

**Pipeline Failure Masking**: `cmd1 | cmd2 || fallback`

**Import Suppression**: `try: import X; except: continue`

**Lazy Imports**: Import inside function/method bodies instead of module top-level
- **Example VIOLATION**:
  ```python
  def process_data():
      from pathlib import Path  # VIOLATION
      from .config import get_config  # VIOLATION
      return Path("/tmp")
  ```
- **Required fix**:
  ```python
  from pathlib import Path
  from scripts.automation.config import get_config

  def process_data():
      return Path("/tmp")
  ```
- **ALLOWED**: Only with extensive multi-line justification explaining why architecturally required (circular dependency cannot refactor, optional heavy dependency must defer)
- **IMPORTANT**: REMOVING lazy imports (moving to top-level) ALWAYS allowed and encouraged, even if have justification
- **Correct approach**: All imports at module top-level; use `TYPE_CHECKING` guard for type-only imports; refactor circular dependencies

**Relative Imports**: Using relative dot notation (`from .module` or `from ..package.module`)
- **Example VIOLATION**:
  ```python
  from .config import get_config  # VIOLATION
  from .logger import get_logger  # VIOLATION
  from ..utils import helper  # VIOLATION
  ```
- **Required fix**:
  ```python
  from scripts.automation.config import get_config
  from scripts.automation.logger import get_logger
  from scripts.utils import helper
  ```
- **ALLOWED**: NEVER - all imports must be absolute
- **IMPORTANT**: REMOVING relative imports (converting to absolute) ALWAYS allowed and encouraged

**Exception → Empty Collection**: `except: return {}/[]/None`

**Missing Related Objects Skipped**: `for id in ids: obj=find(id); if obj: use(obj)` - broken refs ignored

**contextlib.suppress**: `with suppress(Exception): risky()`

**Invalid Input → Sentinel**: `if not valid: return [0.0]*N or "" or {}`

**Finally Unconditional Cleanup**: `try: commit(); finally: discard()` - runs regardless of success

**Exception → False**: `except: return False`

**Partial Success Count**: `count=0; for x: try: process(); count+=1; except: pass; return count`

**Warning + Continue**: `for x: try: op(); except: logger.warning(); continue`

**Missing Exception Handling**: `result = risky()` - no try/except

**Partial Deletion**: `for item: delete(item)` - no failure tracking

**Exception → Response Object**: `except: return (500, "error")` or error_response

**Validation → Bool**: `def is_valid(): return False` - should raise

**Stub → Safe Default**: `def method(): return False/None/[]` - incomplete masked as valid

**Exception Type Conversion**: `except SpecificError: raise DifferentError()` - loses context (use `from e`)

**Exception → String Sentinel**: `except: return "[SENTINEL]"`

**Exception → Queued Status**: `except: return "queued"/"pending"` - failures masked

**Missing Exception Import**: `raise CustomError()` - never imported

**Resource Not Found → Sentinel**: `if not resource: return None/False/[]` WHERE method signature does NOT include `| None` return type OR lacks docstring documenting None return
- **ALLOWED**:
  - Methods with explicit `-> T | None` return type implementing abstract interface requiring None
  - Methods with docstring stating "Returns None if not found" or similar
  - DAO read operations (find_by_id, find_one) returning None for not-found records (standard pattern)

**ImportError → RuntimeError**: `except ImportError: raise RuntimeError()`

**Uncaught HTTP Exception**: `response.raise_for_status()` - no try/except

**User Input Without Validation**: `input = getpass(); use(input)`

**Exception → Error Collection**: `except: results["errors"].append(str(e))`

**Exception → logger.error() Only**: `except e: logger.error(e)` - no raise

**Search Loop Without Exception**: `for x: if cond: result=x; break; use(result or fallback)`

**Missing Timeout Handling**: `result = timeout_op()` - no try/except

**Subprocess Exit Ignored**: `subprocess.run(cmd, check=False)` or `subprocess.call(cmd)`
- **EXCEPTION**: Polyglot shebang wrappers using `exec` command (NOT subprocess)
- **Example NOT A VIOLATION**:
  ```bash
  #!/usr/bin/env bash
  ''':'
  exec "$(dirname "$0")/scripts/ami-run.sh" "$0" "$@"
  '''
  ```
- **Rationale**: `exec` replaces current process (no subprocess created, no exit code to check); standard wrapper pattern; used by pipx, poetry, and other Python tools

**`from __future__` Import Placement with Polyglot Shebang**:
- **REQUIRED**: In files with polyglot shebangs, `from __future__ import annotations` MUST come on line 3 (immediately after shebang), with module docstring on line 4+
- **Example CORRECT**:
  ```python
  #!/usr/bin/env bash
  'exec "$(dirname "$0")/../../scripts/ami-run.sh" "$0" "$@" #'
  from __future__ import annotations

  """Module docstring explaining what this module does."""
  ```
- **Rationale**: Python requires `from __future__` before all code except comments/docstrings. Polyglot shebangs are bash code (not Python comments), so future import must come first. This satisfies both ruff F404 and PEP 257.

**Direct Subprocess Calls**: `subprocess.run([...])`, `subprocess.Popen([...])` outside /base workers
- **Example VIOLATION**:
  ```python
  import subprocess
  result = subprocess.run(["git", "init", "--bare", str(path)], capture_output=True)
  result = subprocess.run(["systemctl", "status", "service"], capture_output=True)
  ```
- **Required fix**:
  ```python
  from base.backend.workers.git_command import GitCommandWorker
  from base.backend.workers.system_command import SystemCommandWorker

  git_worker = GitCommandWorker()
  git_worker.init_bare_repo(path)

  system_worker = SystemCommandWorker()
  system_worker.run_systemctl("status", "service")
  ```
- **IMPORTANT**: All subprocess execution MUST go through /base worker classes
- **ALLOWED**: Only in base/backend/workers/*.py worker implementations themselves
- **Correct approach**: Use GitCommandWorker for git operations, SystemCommandWorker for system commands (systemctl, loginctl, ssh-keygen, etc.); workers use FileSubprocessSync and shutil.which() for security; executable resolution at initialization

**Subprocess Partial Path**: `subprocess.run(["git", ...])`, `subprocess.run(["systemctl", ...])`  (S603/S607)
- **Example VIOLATION**:
  ```python
  subprocess.run(["git", "clone", url, dest])  # Partial path
  subprocess.run(["systemctl", "start", "service"])  # Partial path
  ```
- **Required fix**:
  ```python
  import shutil
  git_path = shutil.which("git")
  if git_path is None:
      raise RuntimeError("git not installed")
  subprocess.run([git_path, "clone", url, dest])
  ```
- **Better fix**: Use /base workers which handle this automatically
- **Correct approach**: Workers resolve absolute paths via shutil.which() at initialization; single subprocess execution point via FileSubprocessSync

**Exception → None**: `except: return None` WHERE method signature does NOT include `| None` return type OR lacks docstring documenting None return
- **ALLOWED**:
  - Methods with explicit `-> T | None` return type implementing abstract interface requiring None
  - Methods with docstring stating "Returns None if not found" or similar
  - DAO read operations (find_by_id, find_one) returning None for not-found records (standard pattern)

**Exception → Numeric Sentinel**: `except: return 1` or `return 0`

**Command → Validation Fail**: `RESULT=$(cmd) || { convert_to_deny; exit 0; }`

**Command → Default Output**: `result=$(cmd || echo "0")`

**Exit Code → String**: `if cmd >/dev/null; then result="PASS"; else result="FAIL"; fi`

**Stderr Redirect**: `command 2>/dev/null` or `2>&1` - suppresses errors

**Uncaught Environment**: `value = os.environ["VAR"]` or `int(os.environ["VAR"])` - no try/except

**Hardcoded Temp Paths**: `Path("/tmp/...")` or `"/tmp/..."` (S108)
- **Example VIOLATION**:
  ```python
  test_file = Path("/tmp/test-file.txt")
  temp_dir = "/tmp/myapp"
  ```
- **Required fix**:
  ```python
  # In tests: use pytest tmp_path fixture
  def test_something(tmp_path):
      test_file = tmp_path / "test-file.txt"

  # In production code: use tempfile module
  import tempfile
  with tempfile.TemporaryDirectory() as temp_dir:
      temp_path = Path(temp_dir) / "myapp"
  ```
- **IMPORTANT**: Never hardcode /tmp paths; security risk (predictable paths, symlink attacks)
- **Correct approach**: Use pytest tmp_path/tmp_path_factory fixtures in tests; use tempfile.TemporaryDirectory/NamedTemporaryFile in production code

**Uncaught JSON Parse**: `data = json.loads(s)` - no try/except

**Assert-Only Validation**: `assert condition` - bypassed in optimized mode

**Exception → Test Skip**: `except e: if "substring" in str(e): pytest.skip()`

**Test Skipping**: `@pytest.mark.skip`, `pytest.skip()`, `unittest.skip()`, `self.skipTest()`
- **ZERO TOLERANCE** - tests must pass or fail, never skip
- **FIX**: Fix the issue or remove test

**Unvalidated Query Result**: `result = execute(sql); use(result)` - no validation

### MEDIUM

**Exit Code → Success**: Script continues after command failure

**Git Suppression**: `git cmd || git fallback || true`

**Exception → Original Input**: `except: return input`

**Warning + Sentinel**: `if invalid: logger.warning(); return None/False`

**Implicit Default via Truthiness**: `value = param or default` - treats falsy as missing

**TODO/Production Comments**: `# TODO: implement` or `# In production...`

**Cleanup Suppression**: `try: session.close(); except: pass`

**Placeholder Before NotImplementedError**: `_ = var; raise NotImplementedError()`

**Implicit Defaults in Optional**: `field: Type|None = Field(default=value)`

**Wrong Exception Type**: `raise ValueError()` - should raise domain-specific

**Dict .get() Silent None**: `value = data.get("key")` - can't distinguish null from missing

**Implicit Defaults in Required**: `field: Type = default`

**Hardcoded Retry Logic**: `max_retries = 3`

**Non-Empty __init__.py**: Imports, `__all__`, re-exports, code in `__init__.py`
- **ALLOWED**: Empty or comments/docstrings only

**Environment Implicit Default**: `os.environ.get("REQUIRED", "")` or `get("VAR", default)`

**Output Format Fallback Chain**: `if result=="EXPECTED": exit 0; elif grep "EXPECTED": exit 0; else: exit 1`

**Test Exception Without Assertion**: `with pytest.raises(Exception): op()` - no match= or assertion

**Test Validates Stub**: `assert stub_method() == expected_sentinel`

**Type Checker Config Suppression**: `ignore_missing_imports = True` or `exclude = pattern`

**Continue/Skip on Error**: `for x: try: process(); except: continue`

**Retry Logic**: `for attempt in range(retries): try: return op(); except: sleep(backoff)`

**Fallback Chain**: `try: return primary(); except: try: return fallback(); except: return default()`

**Script/Executable Not Found → Fallback**: `except (RuntimeError, FileNotFoundError): logger.warning("Falling back"); basic_impl()` - defeats purpose of required scripts/tools

**Orchestrator Root Not Found → Fallback**: `except RuntimeError: logger.warning("Cannot find orchestrator root"); return basic_operation()` - silently degrades functionality

**Logger Warning + Fallback Code**: `logger.warning(f"Falling back to {fallback}"); return fallback_impl()` - masks missing dependencies

**Health Check → False**: `try: service.ping(); return True; except: return False`

**Distributed → Local Fallback**: `except RedisError: return local_cache.get(key)` - loses guarantees

**DateTime Parse → String**: `except ValueError: return value` - wrong type propagated

**Attribute Access or Operator**: `self.attr or default` - None/0/False masked

**Uncaught Type Conversion**: `value = float(input)` - should wrap and raise domain error

**Table Not Found → Empty**: `except TableNotFoundError: return []`

**Rollback in Exception**: `except: for op: try: rollback(op); except: pass`

**Partial Success Without Tracking**: `return {"success": True, "results": results}` if any failed

**JSON Parse → Fallback**: `except JSONDecodeError: data = {}`

## PERMITTED EXCEPTIONS (LIMITED)

**Cleanup in Finally**: `finally: with suppress(Exception): resource.close()`

**Documented "Returns None"**: `-> Config|None` with `"""Returns None if not found."""` docstring

**Test Fixtures**: `@pytest.fixture def empty_list(): return []`

**Not a Git Repo**: `except CalledProcessError as e: if "not a git repository" in e.stderr: return None; raise`

**Print in Production Code**: `print(...)` outside CLI entry points (T201)
- **Example VIOLATION**:
  ```python
  # In backend/service.py:
  def process_data(items):
      print(f"Processing {len(items)} items")  # VIOLATION
      return results
  ```
- **Required fix**:
  ```python
  from loguru import logger

  def process_data(items):
      logger.info(f"Processing {len(items)} items")
      return results
  ```
- **ALLOWED**: Only in CLI entry point scripts (scripts/*.py with `if __name__ == "__main__"`)
- **IMPORTANT**: Use logger for all non-CLI output; print() only for user-facing CLI output
- **Correct approach**: Use loguru logger for debug/info/warning/error; print() only in CLI argument parsers and output formatters

**Commented Code**: Code lines commented out instead of removed (ERA001)
- **Example VIOLATION**:
  ```python
  result = calculate()
  # old_result = legacy_calculate()  # VIOLATION
  # return old_result  # VIOLATION
  return result
  ```
- **Required fix**: Delete commented code, rely on git history
- **ALLOWED**: Inline explanatory comments (not commented-out code)
- **Correct approach**: Remove dead code; use git blame/log to recover if needed
