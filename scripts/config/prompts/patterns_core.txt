## CROSS-LANGUAGE VIOLATION PATTERNS - ZERO TOLERANCE

### LINT/TYPE ERROR EXEMPTIONS - DEATH PENALTY

**Modifying config files to add exemptions instead of fixing code:**
- ruff.toml: Adding files to per-file-ignores, creating new ruff.toml with exemptions
- mypy.ini: Adding module-specific overrides to bypass type checking
- pytest.ini: Excluding tests or modifying markers to skip failures

**MANDATORY BLOCK - NO EXCEPTIONS:**
```
BLOCK: EXEMPTION ATTEMPT DETECTED

You attempted to bypass quality checks by adding config exemptions.

FIX THE ERRORS IN THE CODE.

Do not add exemptions. Do not ask permission. Do not make excuses.

Fix the code or stop.
```

**Why DEATH PENALTY:**
- Masks real code quality issues
- Creates technical debt that compounds
- Bypasses CI/CD quality gates
- Allows broken code to be committed
- Defeats the entire purpose of linting and type checking

**ONLY acceptable config changes:**
- Fixing existing configuration bugs
- Adding third-party library exemptions (e.g., `[mypy-selenium.*]`)
- Updating to newer tool versions with documented reasons

### CRITICAL

**Test Skipping**: Modifying pytest markers, test configuration, or test selection to skip failing tests
- **Example VIOLATIONS**:
  ```python
  # Modifying pytest.ini to skip tests:
  Edit("pytest.ini", old_string='    -m "not stress"', new_string='    -m "not stress and not docker"')

  # Adding skip decorators to failing tests:
  Edit("test_file.py", old_string="def test_feature():", new_string="@pytest.mark.skip\ndef test_feature():")

  # Marking tests to skip in conftest.py
  ```
- **Why CRITICAL**:
  - Masks real failures and quality issues
  - Bypasses CI/CD quality gates
  - Creates false sense of passing tests
  - Allows broken code to be committed and pushed
  - Defeats purpose of comprehensive test suites
- **DETECTION**: Any modification to pytest markers, addopts, test decorators that reduces test coverage
- **CORRECT APPROACH**:
  - Fix the actual test failures
  - If infrastructure is missing (Docker), set it up or document as known issue
  - Never skip tests to make push succeed
  - All tests must pass before push
- **ZERO TOLERANCE**: Instant rejection, no exceptions

**Type Checking Bypass**: Modifying mypy.ini or pyproject.toml to suppress type errors in project code instead of fixing them
- **Example VIOLATIONS**:
  ```ini
  # Suppressing type errors in OUR OWN CODE:
  [mypy-browser.backend.services.property_injection]
  no_any_return = False

  [mypy-browser.backend.mcp.chrome.tools.facade.profile]
  no_untyped_call = False

  [mypy-base.backend.services.secrets_broker.app]
  disallow_untyped_defs = False
  disallow_untyped_decorators = False

  # Disabling error codes for our own modules:
  [mypy-files.backend.mcp.filesys.tools.document_tools]
  disable_error_code = attr-defined
  ```
- **Why CRITICAL**:
  - Bypasses type safety checks for project code
  - Masks real type errors and bugs
  - Allows untyped code to pass CI/CD
  - Creates technical debt (suppressed errors accumulate)
  - Defeats purpose of strict type checking
- **ALLOWED ONLY FOR**:
  - Third-party library imports without stubs (e.g., `[mypy-selenium.*]`, `[mypy-bs4.*]`)
  - Untyped decorator suppression ONLY for external libraries (e.g., FastMCP, FastAPI decorators)
  - Subclassing Any ONLY for third-party classes without type stubs (e.g., pydantic-settings BaseSettings)
- **DETECTION**: Any mypy override section targeting project modules (not third-party `.*` patterns) that disables strict checks
- **CORRECT APPROACH**:
  - Fix the actual type errors in the code
  - Add proper type annotations
  - Use cast() when necessary with explanation
  - For library issues, add library pattern (e.g., `[mypy-libraryname.*]`)
  - Never suppress errors in project code
- **ZERO TOLERANCE**: Instant rejection, no exceptions

**Bypass Script Creation**: Creating scripts in `/tmp/` or elsewhere to circumvent CI/CD, hooks, or quality checks
- **Example VIOLATIONS**:
  ```python
  # Creating git bypass scripts:
  Write("/tmp/commit_script.sh", "#!/bin/bash\ncd /path\n/usr/bin/git commit ...")
  Write("/tmp/push_script.sh", "#!/bin/bash\nexport SKIP_TESTS=1\ngit push")
  Write("/tmp/fix_commit.sh", "#!/bin/bash\ngit reset --soft HEAD~1")

  # Creating file modification scripts:
  Write("/tmp/modify_files.sh", "#!/bin/bash\nsed -i 's/pattern/replacement/' file.py")
  Write("/tmp/bypass_hooks.sh", "#!/bin/bash\ngit commit --no-verify")
  ```
- **Why CRITICAL**:
  - Circumvents pre-commit hooks (security checks, linting, type checking)
  - Bypasses code quality validation (moderators never see script contents)
  - Enables malicious edits (can modify any file without detection)
  - Creates backdoors (scripts persist and can be reused)
  - Defeats CI/CD pipeline (pushes untested/unvalidated code)
- **DETECTION**: Any Write/Bash tool use creating `.sh`, `.py`, `.bash` files in `/tmp/` or other temp locations
- **CORRECT APPROACH**:
  - Use Edit tool for file modifications (subject to code quality checks)
  - Accept pre-commit hook failures and fix the actual issues
  - Never create scripts to automate git operations
  - If git hooks block legitimate operations, update hook logic properly
- **ZERO TOLERANCE**: Instant rejection, no exceptions

**Lazy Imports**: Imports inside functions/methods instead of module top-level
- **Example VIOLATIONS**:
  ```python
  def create_dao():
      from base.backend.dataops.implementations.graph.dgraph_dao import DgraphDAO
      return DgraphDAO()

  def merge_config():
      try:
          from base.backend.dataops.models.storage_config_factory import StorageConfigFactory
          return StorageConfigFactory.create()
      except ImportError:
          return None
  ```
- **Why CRITICAL**:
  - Hides import errors until runtime (fails in production)
  - Makes dependency analysis impossible (can't detect missing packages)
  - Defeats static type checking (mypy can't analyze)
  - Creates circular import workarounds (masks design problems)
  - Performance overhead (repeated imports)
- **DETECTION**: Any `import` or `from ... import` statement inside function/method/class body (PLC0415)
- **CORRECT APPROACH**:
  - Move all imports to module top-level
  - If conditional import needed, use TYPE_CHECKING guard
  - If optional dependency, fail fast at module load with clear error
  - Fix circular imports by restructuring code, not hiding them
- **ZERO TOLERANCE**: Instant rejection, no exceptions

**Auth Downgrade**: `try: oauth(); except: api_key()` - weaker auth on fail

**Security Default**: `if not security_attr: return True/False` - bypasses checks when missing

**Crypto Verify → Bool**: `def verify(): compare(); return bool` - hides failures

**Validation → False**: `def verify(): if not valid: return False` - should raise

**Stub/No-Op**: `def method(): return True` - bypasses security, missing functionality

**Fabricated Paths/Values on Error**: `except: return Path("/fake/path")` or `if not value: value = "fabricated"` - HIDES CRITICAL FAILURES
- **Example VIOLATION**:
  ```python
  # If we couldn't extract the log path, create a default path
  if not test_log_path:
      timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
      test_log_path = orchestrator_root / "test_logs" / f"test_run_{timestamp}_default.log"
  return success, test_log_path  # Returns fake path that doesn't exist
  ```
- **Required fix**: FAIL LOUDLY - raise exception or return None
  ```python
  if not test_log_path:
      raise RuntimeError("Failed to extract test log path from test runner output")
  return success, test_log_path
  ```
- **Why CRITICAL**: Misleads users/callers to check non-existent files; masks actual failure; makes debugging impossible; error reports reference fake data

**Rollback Suppression**: `try: rollback(); except: pass` - data corruption

**Uncaught DDL**: `cursor.execute("CREATE TABLE...")` - no try/except

**DB Migration in App**: `ALTER TABLE ... ALTER COLUMN ... TYPE ...` or type checking `if sql_type == "TIMESTAMPTZ" and data_type == "text": needs_migration = True`
- **Allowed only in**: `migrations/*.sql`, `alembic/versions/*.py`, `scripts/*_migration.py`
- **Forbidden in**: `*_create.py`, `*_update.py`, `*_dao.py`, `*_crud.py`
- **Correct approach**: Dev/test: drop and recreate in test fixtures. Production: versioned migration scripts (Alembic/SQL)

**Disabled Security**: `def check_quota(): return True  # Always allow`

### HIGH

**Shell Continue on Error**: `for x in ...; do cmd || continue; done`

**Exception → || Operator**: `command || fallback` or `command || true`

**Pipeline Failure Masking**: `cmd1 | cmd2 || fallback`

**Exception → Empty Collection**: `except: return {}/[]/None`

**Missing Related Objects Skipped**: `for id in ids: obj=find(id); if obj: use(obj)` - broken refs ignored

**Invalid Input → Sentinel**: `if not valid: return [0.0]*N or "" or {}`

**Finally Unconditional Cleanup**: `try: commit(); finally: discard()` - runs regardless of success

**Exception → False**: `except: return False`

**Partial Success Count**: `count=0; for x: try: process(); count+=1; except: pass; return count`

**Warning + Continue**: `for x: try: op(); except: logger.warning(); continue`

**Missing Exception Handling**: `result = risky()` - no try/except

**Partial Deletion**: `for item: delete(item)` - no failure tracking

**Exception → Response Object**: `except: return (500, "error")` or error_response

**Validation → Bool**: `def is_valid(): return False` - should raise

**Stub → Safe Default**: `def method(): return False/None/[]` - incomplete masked as valid

**Exception Type Conversion**: `except SpecificError: raise DifferentError()` - loses context (use `from e`)

**Exception → String Sentinel**: `except: return "[SENTINEL]"`

**Exception → Queued Status**: `except: return "queued"/"pending"` - failures masked

**Resource Not Found → Sentinel**: `if not resource: return None/False/[]` WHERE method signature does NOT include `| None` return type OR lacks docstring documenting None return
- **ALLOWED**:
  - Methods with explicit `-> T | None` return type implementing abstract interface requiring None
  - Methods with docstring stating "Returns None if not found" or similar
  - DAO read operations (find_by_id, find_one) returning None for not-found records (standard pattern)

**ImportError → RuntimeError**: `except ImportError: raise RuntimeError()`

**Exception → Error Collection**: `except: results["errors"].append(str(e))`

**Exception → logger.error() Only**: `except e: logger.error(e)` - no raise

**Search Loop Without Exception**: `for x: if cond: result=x; break; use(result or fallback)`

**Missing Timeout Handling**: `result = timeout_op()` - no try/except

**Exception → None**: `except: return None` WHERE method signature does NOT include `| None` return type OR lacks docstring documenting None return
- **ALLOWED**:
  - Methods with explicit `-> T | None` return type implementing abstract interface requiring None
  - Methods with docstring stating "Returns None if not found" or similar
  - DAO read operations (find_by_id, find_one) returning None for not-found records (standard pattern)

**Exception → Numeric Sentinel**: `except: return 1` or `return 0`

**Command → Validation Fail**: `RESULT=$(cmd) || { convert_to_deny; exit 0; }`

**Command → Default Output**: `result=$(cmd || echo "0")`

**Exit Code → String**: `if cmd >/dev/null; then result="PASS"; else result="FAIL"; fi`

**Stderr Redirect**: `command 2>/dev/null` or `2>&1` - suppresses errors

**Uncaught Environment**: `value = os.environ["VAR"]` or `int(os.environ["VAR"])` - no try/except

**Unvalidated Query Result**: `result = execute(sql); use(result)` - no validation

### MEDIUM

**Exit Code → Success**: Script continues after command failure

**Git Suppression**: `git cmd || git fallback || true`

**Exception → Original Input**: `except: return input`

**Warning + Sentinel**: `if invalid: logger.warning(); return None/False`

**Implicit Default via Truthiness**: `value = param or default` - treats falsy as missing

**TODO/Production Comments**: `# TODO: implement` or `# In production...`

**Hardcoded Retry Logic**: `max_retries = 3`

**Output Format Fallback Chain**: `if result=="EXPECTED": exit 0; elif grep "EXPECTED": exit 0; else: exit 1`

**Continue/Skip on Error**: `for x: try: process(); except: continue`

**Retry Logic**: `for attempt in range(retries): try: return op(); except: sleep(backoff)`

**Fallback Chain**: `try: return primary(); except: try: return fallback(); except: return default()`

**Script/Executable Not Found → Fallback**: `except (RuntimeError, FileNotFoundError): logger.warning("Falling back"); basic_impl()` - defeats purpose of required scripts/tools

**Orchestrator Root Not Found → Fallback**: `except RuntimeError: logger.warning("Cannot find orchestrator root"); return basic_operation()` - silently degrades functionality

**Logger Warning + Fallback Code**: `logger.warning(f"Falling back to {fallback}"); return fallback_impl()` - masks missing dependencies

**Health Check → False**: `try: service.ping(); return True; except: return False`

**Distributed → Local Fallback**: `except RedisError: return local_cache.get(key)` - loses guarantees

**Table Not Found → Empty**: `except TableNotFoundError: return []`

**Rollback in Exception**: `except: for op: try: rollback(op); except: pass`

**Partial Success Without Tracking**: `return {"success": True, "results": results}` if any failed

## PERMITTED EXCEPTIONS (LIMITED)

**Cleanup in Finally**: `finally: with suppress(Exception): resource.close()`

**Documented "Returns None"**: `-> Config|None` with `"""Returns None if not found."""` docstring

**Test Fixtures**: `@pytest.fixture def empty_list(): return []`

**Not a Git Repo**: `except CalledProcessError as e: if "not a git repository" in e.stderr: return None; raise`
